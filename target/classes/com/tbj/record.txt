1：分布式事物中消息最终一致性的处理方案
情景描述：当还款请求到达account中，account表需要根据主键更新数据数据表，在更新成功之后，需要给MQ中发送一条消息，然后clms端做监听，当收到消息时，处理这条消息。然后更新授信金额。

在这个场景中，我们可能出现问题的地方
①：当我们更新account表数据库时，出现异常，那么我们有本地事物回滚策略，估不会出现数据不一致问题。
②：当我们本地更新account成功，然后发送消息到MQ中时，如果这个时候MQ挂掉，那么我们调用端还是会抛出异常。导致本地事物回滚。那么也不会出现问题。
③：当我们将数据成功发送到MQ中时，如果此时MQ中的数据成功发送到clms中，然后clms处理过程中产生失败，那么此时MQ中的数据将会剔除，造成数据不一致的情况。
如果要解决③所生产的问题，我们现在的MQ大多数都支持ack，但是如果引入ack就会出现另外的问题。比如：clms处理成功，此时想MQ中做ack回执，如果此时MQ挂掉。
我们如果对clms中的处理进行本地事物回滚，那么会造成大量的资源浪费。如果我们不做回滚，那么就会出现一条消息被多次消费的问题。估为了解决这些问题。我们来引入
一套完整的解决方案。

rabbitMQ+redis+MqSql+aop
①：当我们需要进行一次更新account数据之前，我们先将数据预存到 mysql数据库的日志表 + redis缓存中。缓存数据类型使用 hash， key 为 pre_data（预发送数据）
  I：在这一步中，可能  插入 mysql 数据库日志表出现异常，根据本地事物就可以回滚，估数据一致、
  II：如果日志插入正常，这个时候 redis出现异常，那么也会造成日志表回滚。redis中插入失败。估数据一致。
②：处理业务逻辑。更新account表。
  I：如果此时，更新失败，那么日志表将一起回滚，此时删除redis中的数据。 如果此时删除redis中的数据，删除失败，那么在定时任务重试中，会先去日志表中查一下，此记录是否存在，如果
	记录不存在，那么删除redis中的数据即可。估数据一致。
③：当account业务处理成功。我们需要拿出redis中预处理的数据。然后将数据放入到 suc_send_data（成功发送的hash）中。然后再发送MQ消息。再删除 pre_data 中的数据。
  I：从redis中拿出数据并放入到 suc_send_data 这一步，可以使用 redis的管道处理。如果这一步失败，那么定时任务到时候会再次调用。估数据一致。
  II： 如果发送MQ时出现异常，定时任务处理
  III：如果删除pre_data中的数据出现异常,定时任务处理。

这边其实是有问题的，关于第二步和第三部。因为不管是第二步发生异常还是第三部发生异常，造成的结果都是 redis中存了两份数据，在pre_date中一份，在 suc_send_data 中一份。
这个时候我们判断不出，到底是数据发送到MQ中了么？定时任务该如何处理这种情况。是继续发送到MQ呢，还是不发送。我们这里统一在定时任务中进行数据发送并删除pre_data中的数据。
如果消息进行了重复发送，那么在clms中做幂等性判断。

这个时候 account 这边已经处理结束。我们再来看看clms应该如何处理。

①：首先，接到 MQ中的消息。根据key 去 suc_send_data 中查询，如果不存在，那么直接返回并删除MQ中的消息。
②：去clms的日志表中查看此key是否已经存在，如果存在，那么直接ack回执，删除MQ中的消息。
③：获取  suc_send_data 中的发送次数，如果次数超过我们设定的次数，那么将此条消息从 suc_send_data 移入 死亡队列。进行人工处理。并进行ack回执，删除MQ中的消息
④：业务处理 + 插入日志表。如果失败，本地事物回滚。不删除MQ中的消息。
⑤：处理完成，ack 回执。删除MQ中的消息。
 

	
2：计息模式，日切的横向扩展。
原始计息只是针对经销商进行计息，每天凌晨12点10.计算上一天产生的利息，罚息，滞纳金等。利息是每天产生，罚息是对上一期没有按时还利息，滞纳金只收一次。每月20号查看上一期利息是否还完，如果没有还完则记一笔滞纳金。
计息从 滞纳金->利息->罚息这样的顺序。
模式：
经销商计息:经销商偿还滞纳金，利息，罚息，本金。
厂家计息：厂家支付利息逾期不生成罚息，滞纳金。本金还是经销商偿还。
分开计息：产生利息的总和，按照比例分。

还款：
经销商：先还罚息，滞纳金，利息，本金。
厂家：直接还利息。

这业务增加的同时，如果还是用if判断会增加代码的复杂性。我们使用  注解+策略模式+线程池完成计息的改造工作。
以前是单线程，线上一笔计息需要2小时，现在改为多线程，分开跑。这样大大节约了时间。
使用 注解+策略+模板方法模式 大大增强了代码的横向扩展。


在进行计息结束之后，需要进行试算平衡校验。查看日切是否成功。还有因为我们使用的是线程池，在处理完计息之后，我们还需要进行线程池的关闭。这个时候我们需要知道什么时候计息执行完毕（此处我们其实可以使用观察者模式）。
我们使用一个 volatile 的 atomicInteger，在定时任务执行之前，我们计算出要计息的贷款数量，在执行计息过程中，每次减一。当此变量为0的时候，就表示计息结束。这个时候我们的监视器就进行试算平衡操作。
在之前的代码中，错了就只能回滚或者手动进行数据订正。现在我们将出现错误的贷款记录下来放到数据库中。进行手动执行。这样就可以避免数据订正。

当传给我们一个 list的贷款列表。我们需要初始化一个线程池（单利），然后将 list 传到这个 线程池的对象中。然后 for 循环 submit 任务。 我们需要一个实现了 Callable 接口的类来处理 传过来的 贷款信息。
因为不管是 单例的线程池的类还是我们的任务类，都是我们自己创建的，估spring 的IOC 是不能用的，所以我们如何获取 处理 贷款的 Service，这是一个问题。

所以我们在项目启动之初，就需要获取和处理计息相关的service，我们约定把计息相关的service放在一个包下，这样我们通过 File 类，就可以轻易获取此包下的 class文件，获取了 .class 文件，那么我们需要
验证此 .class 文件对应的类，是否有我们制定的注解。然后或许 类名，根据 application.getBean()； 获取此类的对象。然后将 注解类型作为 type， 对象作为 value，放到一个map中。然后提供一个方法供
外部调用。

因为我们的 loan对象，有类型， 这个类型就是对应 map中的key，这样我们就能轻易或许 service，然后用service调用执行方法。进行计息。





3：缓存数据和数据库数据双写不一致问题
将先更新数据库在删除缓存 改为 先删除缓存，在更新数据库。在并发量不大的情况下。可以满足双写一致的问题。

在并发量大的情况下：该如何处理：

我们在项目初始化时，初始化一个线程池。在创建一个任务对象，每个任务对象拥有一个  ArrayBlockQueue(有界阻塞队列),将所有的阻塞队列添加到 一个 List 中。在任务对象中，死循环 自己所拥有的队列。当队列中有
数据时，取出数据，得到封装好的 Request 对象，然后执行此 Request.

我们需要封装一个 Request 对象, 然后每个对应的请求有一个自己的实现类, 比如 accountRequest,  LoanInfoReuqest 等等。
然后我们接收到请求，将请求参数封装到 Request 对象中，然后 创建一个专门 处理 Request 请求的类。如果是一个更新请求（比如：loanInfo的更新请求，那么我们就设置 loan_info_1，1表示此贷款的id），
那么我们设置一个标识为 true，如果是一个读请求，那么我们去获取此读请求的标识（比如：loanInfo的读请求，我们获取 key 为 loan_info_2，2为此loanInfo的id）。如果标识不为true，那么我们直接
设置此标识为 false，然后根据此 key， hash(key) 得到阻塞队列。将此请求Request 对象 put 进 queue 中。

线程池+阻塞队列 可以解决。










